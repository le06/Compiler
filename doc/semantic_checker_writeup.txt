Division of Work
----------------
We split the work around the intermediate representation:
 - Patrick (patrickv) worked mainly around producing the IR
 - Jae (jaechung) worked on walking the IR and doing the semantic checks
   - Both of us worked on actually implementing the IR

The other group members did not contribute.

Clarifications
--------------
In the Decaf language:

    int a, a[];
    int a() {
    
    }

is unambiguous, so we treat it as such. In the given example, there 
are three different 'a' identifiers, but all must be accessed in 
different ways. We decided this was ok.

    for (a = b; c) {
    
    }
    
We agreed that variable a belongs in the inner scope, and variables b and c in
the outer scope in this example.

Overview
--------

The semantic checker operates through the DecafChecker class, which is 
constructed by passing a parser as a parameter. The checker is run by
running DecafChecker.check(), and if there is an error, DecafChecker.getError()
will return true. If there is an error, Main terminates with an exit
code of -1.

We began by designing an intermediate representation (Ir) based on the
one given in the project handout. This Ir is located in the package
'edu.mit.compilers.checker.Ir'.

We altered the ANTLR parser grammar to generate an AST that was similar to
the intermediate representation that we designed. From there, creating the 
IR tree revolved around recursively evaluating the AST generated by ANTLR
and transforming all of the nodes to the associated IR nodes. This functionality
is implemented in edu.mit.compilers.checker.IrGenerator.java.

The generated IR is itself traversed by a visitor class. IR nodes implement
IrNode or IrExpression and accept visitors that implement the IrNodeVisitor
class, which IrNodeChecker implements. All of this is contained in the package
edu.mit.compilers.checker.Ir.

Interesting Implementation Issues
---------------------------------
- In altering the parser grammar, in order to create nodes with no logical
  parent, I created some tokens that do not correspond to a literal and used
  them as the parent (e.g. BLOCK, FUNCTION_CALL, etc).

- Getting the semantic checker to recognize negative literals was slightly
  tricky business. That is, "-9223372036854775808" would be read as
  "9223372036854775808" first, which is out of bounds itself. The solution was
  to go higher and use BigIntegers. To check bounds, a BigInteger is casted to
  a Long. If the Long is truncated, it must also be out-of-bounds.

- IrExpression was originally an abstract class. Changing it to an interface
  was an excellent sanity measure in regards to IR generation. Other changes to
  the original IR design reflect this (consider how we addressed commas in
  variable declarations).

- Converting unary exprs into negative literals also required a slight hack of
  the IR generator, since the nodes have no knowledge of their parents.
  Implementing this during semantic checking would have been painful as the
  whole IR would have to be redesigned.

- While Decaf forbids this, the implementation of the symbol tables does not,
  without significant modification, allow function overloading. There is also
  no distinction between formal parameters and locals.

Known Issues
------------
- The debug output of the Ir tree contains some extraneous newlines, but that
  does not affect the correctness of the output.
