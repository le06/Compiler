Division of Work
----------------
We split the work around the intermediate representation:
 - Patrick (patrickv) worked mainly around producing the IR
 - Jae (jaechung) worked on walking the IR and doing the semantic checks
   - Both of us worked on actually implementing the IR

The other group members did not contribute.

Clarifications
--------------
In the Decaf language:

    int a, a[];
    int a() {
    
    }

is unambiguous, so we treat it as such. In the given example, there 
are three different 'a' identifiers, but all must be accessed in 
different ways, so this is ok.


Overview
--------

The semantic checker operates through the DecafChecker class, which is 
constructed by passing a parser as a parameter. The checker is run by
running DecafChecker.check(), and if there is an error, DecafChecker.getError()
will return true. If there is an error, Main terminates with an exit
code of -1.

We began by designing an intermediate representation (Ir) based on the
one given in the project handout. This Ir is located in the package
'edu.mit.compilers.checker.Ir'. 

We altered the ANTLR parser grammar to generate an AST that was similar to
the intermediate representation that we designed. From there, creating the 
IR tree revolved around recursively evaluating the AST generated by antlr
and transforming all of the nodes to the associated IR nodes. This functionality
is implemented in edu.mit.comilers.checker.IrGenerator.java




Interesting Implementation Issues
---------------------------------
- In altering the parser grammar, in order to create nodes with no logical
  parent, I created some tokens that do not correspond to a literal and used
  them as the parent (e.g. BLOCK, FUNCTION_CALL, etc).



Known Issues
------------
- The debug output of the Ir tree contains some extraneous newlines, but that
  does not affect the correctness of the output.